from lale.lib.sklearn import AdaBoostClassifier as AdaBoostClassifier_handwritten
from lale.lib.sklearn import AdaBoostRegressor as AdaBoostRegressor_handwritten
from lale.lib.sklearn import BaggingClassifier as BaggingClassifier_handwritten
from lale.lib.sklearn import ColumnTransformer as ColumnTransformer_handwritten
from lale.lib.sklearn import DecisionTreeClassifier as DecisionTreeClassifier_handwritten
from lale.lib.sklearn import DecisionTreeRegressor as DecisionTreeRegressor_handwritten
from lale.lib.sklearn import ExtraTreesClassifier as ExtraTreesClassifier_handwritten
from lale.lib.sklearn import ExtraTreesRegressor as ExtraTreesRegressor_handwritten
from lale.lib.sklearn import FeatureAgglomeration as FeatureAgglomeration_handwritten
from lale.lib.sklearn import FunctionTransformer as FunctionTransformer_handwritten
from lale.lib.sklearn import GaussianNB as GaussianNB_handwritten
from lale.lib.sklearn import GradientBoostingClassifier as GradientBoostingClassifier_handwritten
from lale.lib.sklearn import GradientBoostingRegressor as GradientBoostingRegressor_handwritten
from lale.lib.sklearn import KNeighborsClassifier as KNeighborsClassifier_handwritten
from lale.lib.sklearn import KNeighborsRegressor as KNeighborsRegressor_handwritten
from lale.lib.sklearn import LinearRegression as LinearRegression_handwritten
from lale.lib.sklearn import LinearSVC as LinearSVC_handwritten
from lale.lib.sklearn import LogisticRegression as LogisticRegression_handwritten
from lale.lib.sklearn import MinMaxScaler as MinMaxScaler_handwritten
from lale.lib.sklearn import MissingIndicator as MissingIndicator_handwritten
from lale.lib.sklearn import MLPClassifier as MLPClassifier_handwritten
from lale.lib.sklearn import MultinomialNB as MultinomialNB_handwritten
from lale.lib.sklearn import NMF as NMF_handwritten
from lale.lib.sklearn import Normalizer as Normalizer_handwritten
from lale.lib.sklearn import Nystroem as Nystroem_handwritten
from lale.lib.sklearn import OneHotEncoder as OneHotEncoder_handwritten
from lale.lib.sklearn import OrdinalEncoder as OrdinalEncoder_handwritten
from lale.lib.sklearn import PassiveAggressiveClassifier as PassiveAggressiveClassifier_handwritten
from lale.lib.sklearn import PCA as PCA_handwritten
from lale.lib.sklearn import Pipeline as Pipeline_handwritten
from lale.lib.sklearn import PolynomialFeatures as PolynomialFeatures_handwritten
from lale.lib.sklearn import QuadraticDiscriminantAnalysis as QuadraticDiscriminantAnalysis_handwritten
from lale.lib.sklearn import QuantileTransformer as QuantileTransformer_handwritten
from lale.lib.sklearn import RandomForestClassifier as RandomForestClassifier_handwritten
from lale.lib.sklearn import RandomForestRegressor as RandomForestRegressor_handwritten
from lale.lib.sklearn import RFE as RFE_handwritten
from lale.lib.sklearn import Ridge as Ridge_handwritten
from lale.lib.sklearn import RidgeClassifier as RidgeClassifier_handwritten
from lale.lib.sklearn import RobustScaler as RobustScaler_handwritten
from lale.lib.sklearn import SelectKBest as SelectKBest_handwritten
from lale.lib.sklearn import SGDClassifier as SGDClassifier_handwritten
from lale.lib.sklearn import SGDRegressor as SGDRegressor_handwritten
from lale.lib.sklearn import SimpleImputer as SimpleImputer_handwritten
from lale.lib.sklearn import StandardScaler as StandardScaler_handwritten
from lale.lib.sklearn import SVC as SVC_handwritten
from lale.lib.sklearn import SVR as SVR_handwritten
from lale.lib.sklearn import TfidfVectorizer as TfidfVectorizer_handwritten
from lale.lib.sklearn import VotingClassifier as VotingClassifier_handwritten


from lale.lib.autogen import AdaBoostClassifier as AdaBoostClassifier_autogen
from lale.lib.autogen import AdaBoostRegressor as AdaBoostRegressor_autogen
#from lale.lib.autogen import BaggingClassifier as BaggingClassifier_autogen
#from lale.lib.autogen import ColumnTransformer as ColumnTransformer_autogen
from lale.lib.autogen import DecisionTreeClassifier as DecisionTreeClassifier_autogen
from lale.lib.autogen import DecisionTreeRegressor as DecisionTreeRegressor_autogen
from lale.lib.autogen import ExtraTreesClassifier as ExtraTreesClassifier_autogen
from lale.lib.autogen import ExtraTreesRegressor as ExtraTreesRegressor_autogen
#from lale.lib.autogen import FeatureAgglomeration as FeatureAgglomeration_autogen
from lale.lib.autogen import FunctionTransformer as FunctionTransformer_autogen
from lale.lib.autogen import GaussianNB as GaussianNB_autogen
from lale.lib.autogen import GradientBoostingClassifier as GradientBoostingClassifier_autogen
from lale.lib.autogen import GradientBoostingRegressor as GradientBoostingRegressor_autogen
from lale.lib.autogen import KNeighborsClassifier as KNeighborsClassifier_autogen
from lale.lib.autogen import KNeighborsRegressor as KNeighborsRegressor_autogen
from lale.lib.autogen import LinearRegression as LinearRegression_autogen
from lale.lib.autogen import LinearSVC as LinearSVC_autogen
from lale.lib.autogen import LogisticRegression as LogisticRegression_autogen
from lale.lib.autogen import MinMaxScaler as MinMaxScaler_autogen
from lale.lib.autogen import MissingIndicator as MissingIndicator_autogen
from lale.lib.autogen import MLPClassifier as MLPClassifier_autogen
from lale.lib.autogen import MultinomialNB as MultinomialNB_autogen
from lale.lib.autogen import NMF as NMF_autogen
from lale.lib.autogen import Normalizer as Normalizer_autogen
from lale.lib.autogen import Nystroem as Nystroem_autogen
from lale.lib.autogen import OneHotEncoder as OneHotEncoder_autogen
from lale.lib.autogen import OrdinalEncoder as OrdinalEncoder_autogen
from lale.lib.autogen import PassiveAggressiveClassifier as PassiveAggressiveClassifier_autogen
from lale.lib.autogen import PCA as PCA_autogen
#from lale.lib.autogen import Pipeline as Pipeline_autogen
from lale.lib.autogen import PolynomialFeatures as PolynomialFeatures_autogen
from lale.lib.autogen import QuadraticDiscriminantAnalysis as QuadraticDiscriminantAnalysis_autogen
from lale.lib.autogen import QuantileTransformer as QuantileTransformer_autogen
from lale.lib.autogen import RandomForestClassifier as RandomForestClassifier_autogen
from lale.lib.autogen import RandomForestRegressor as RandomForestRegressor_autogen
#from lale.lib.autogen import RFE as RFE_autogen
from lale.lib.autogen import Ridge as Ridge_autogen
from lale.lib.autogen import RidgeClassifier as RidgeClassifier_autogen
from lale.lib.autogen import RobustScaler as RobustScaler_autogen
#from lale.lib.autogen import SelectKBest as SelectKBest_autogen
from lale.lib.autogen import SGDClassifier as SGDClassifier_autogen
from lale.lib.autogen import SGDRegressor as SGDRegressor_autogen
from lale.lib.autogen import SimpleImputer as SimpleImputer_autogen
from lale.lib.autogen import StandardScaler as StandardScaler_autogen
from lale.lib.autogen import SVC as SVC_autogen
from lale.lib.autogen import SVR as SVR_autogen
#from lale.lib.autogen import TfidfVectorizer as TfidfVectorizer_autogen
#from lale.lib.autogen import VotingClassifier as VotingClassifier_autogen

ops = ["AdaBoostClassifier", "AdaBoostRegressor", "BaggingClassifier", "ColumnTransformer", "DecisionTreeClassifier", "DecisionTreeRegressor", "ExtraTreesClassifier", "ExtraTreesRegressor", "FeatureAgglomeration", "FunctionTransformer", "GaussianNB", "GradientBoostingClassifier", "GradientBoostingRegressor", "KNeighborsClassifier", "KNeighborsRegressor", "LinearRegression", "LinearSVC", "LogisticRegression", "MinMaxScaler", "MissingIndicator", "MLPClassifier", "MultinomialNB", "NMF", "Normalizer", "Nystroem", "OneHotEncoder", "OrdinalEncoder", "PassiveAggressiveClassifier", "PCA", "Pipeline", "PolynomialFeatures", "QuadraticDiscriminantAnalysis", "QuantileTransformer", "RandomForestClassifier", "RandomForestRegressor", "RFE", "Ridge", "RidgeClassifier", "RobustScaler", "SelectKBest", "SGDClassifier", "SGDRegressor", "SimpleImputer", "StandardScaler", "SVC", "SVR", "TfidfVectorizer", "VotingClassifier"]
no_autogen = ["BaggingClassifier", "ColumnTransformer", "FeatureAgglomeration", "Pipeline", "RFE", "SelectKBest", "TfidfVectorizer", "VotingClassifier"]
ddict = {}

if 0:
	with open("delllll.py", "w") as f:
		for op in ops:
			print("\telif x == \"" + op + "\":\n\t\treturn " + op + "_handwritten", file = f)
if 0:
	with open("delllll.py", "w") as f:
		for op in ops:
			if op in no_autogen:
				print("\telif x == \"" + op + "\":\n\t\treturn None", file = f)
			else:
				print("\telif x == \"" + op + "\":\n\t\treturn " + op + "_autogen", file = f)

if 1:
	for op in ops:
		s = op
		#print(s)
		j = 0
		k = ""
		for i in range(0,len(s)):
			if "A" <= s[i] <= "Z":
				if j == 0:
					k += s[i].lower()
				else:
					k += "_"
					k += s[i].lower()
				j += 1
			else:
				k += s[i]
		if op == "GaussianNB":
			k = "gaussian_nb"
		elif op == "LinearSVC":
			k = "linear_svc"
		elif op == "MLPClassifier":
			k = "mlp_classifier"
		elif op == "MultinomialNB":
			k = "multinomial_nb"
		elif op == "NMF":
			k = "nmf"
		elif op == "PCA":
			k = "PCA"
		elif op == "RFE":
			k = "rfe"
		elif op == "SGDClassifier":
			k = "sgd_classifier"
		elif op == "SGDRegressor":
			k = "sgd_regressor"
		elif op == "SVC":
			k = "svc"
		elif op == "SVR":
			k = "svr"
		elif op == "PolynomialFeatures":
			k = "polynomial_feature"
		
		ddict[op] = k

def get_JSS_WP_path(x):
	y = "/JSS_path/"
	y += x
	y +=".py"
	return y

def get_JSS_ALL_WP_path(x):
	y = "/JSS_path/"
	y += x
	y += ".py"
	return y

def revDict():
	rev_dict = {v: k for k, v in ddict.items()}

def get_lale_handwritten(x):
	if x == "BaggingClassifier":
		return BaggingClassifier_handwritten
	elif x == "KNeighborsClassifier":
		return KNeighborsClassifier_handwritten
	elif x == "LogisticRegression":
		return LogisticRegression_handwritten
	elif x == "PCA":
		return PCA_handwritten
	elif x == "ColumnTransformer":
		return ColumnTransformer_handwritten
	elif x == "Ridge":
		return Ridge_handwritten
	elif x == "GradientBoostingRegressor":
		return GradientBoostingRegressor_handwritten
	elif x == "Nystroem":
		return Nystroem_handwritten
	elif x == "QuantileTransformer":
		return QuantileTransformer_handwritten
	elif x == "RFE":
		return RFE_handwritten
	elif x == "SVC":
		return SVC_handwritten
	elif x == "OrdinalEncoder":
		return OrdinalEncoder_handwritten
	elif x == "SGDRegressor":
		return SGDRegressor_handwritten
	elif x == "FeatureAgglomeration":
		return FeatureAgglomeration_handwritten
	elif x == "MissingIndicator":
		return MissingIndicator_handwritten
	elif x == "Normalizer":
		return Normalizer_handwritten
	elif x == "RobustScaler":
		return RobustScaler_handwritten
	elif x == "TfidfVectorizer":
		return TfidfVectorizer_handwritten
	elif x == "OneHotEncoder":
		return OneHotEncoder_handwritten
	elif x == "QuadraticDiscriminantAnalysis":
		return QuadraticDiscriminantAnalysis_handwritten
	elif x == "RandomForestClassifier":
		return RandomForestClassifier_handwritten
	elif x == "LinearSVC":
		return LinearSVC_handwritten
	elif x == "GaussianNB":
		return GaussianNB_handwritten
	elif x == "SelectKBest":
		return SelectKBest_handwritten
	elif x == "FunctionTransformer":
		return FunctionTransformer_handwritten
	elif x == "DecisionTreeClassifier":
		return DecisionTreeClassifier_handwritten
	elif x == "PassiveAggressiveClassifier":
		return PassiveAggressiveClassifier_handwritten
	elif x == "LinearRegression":
		return LinearRegression_handwritten
	elif x == "MLPClassifier":
		return MLPClassifier_handwritten
	elif x == "RidgeClassifier":
		return RidgeClassifier_handwritten
	elif x == "AdaBoostClassifier":
		return AdaBoostClassifier_handwritten
	elif x == "Pipeline":
		return Pipeline_handwritten
	elif x == "ExtraTreesClassifier":
		return ExtraTreesClassifier_handwritten
	elif x == "VotingClassifier":
		return VotingClassifier_handwritten
	elif x == "SVR":
		return SVR_handwritten
	elif x == "ExtraTreesRegressor":
		return ExtraTreesRegressor_handwritten
	elif x == "KNeighborsRegressor":
		return KNeighborsRegressor_handwritten
	elif x == "NMF":
		return NMF_handwritten
	elif x == "StandardScaler":
		return StandardScaler_handwritten
	elif x == "RandomForestRegressor":
		return RandomForestRegressor_handwritten
	elif x == "DecisionTreeRegressor":
		return DecisionTreeRegressor_handwritten
	elif x == "GradientBoostingClassifier":
		return GradientBoostingClassifier_handwritten
	elif x == "AdaBoostRegressor":
		return AdaBoostRegressor_handwritten
	elif x == "PolynomialFeatures":
		return PolynomialFeatures_handwritten
	elif x == "SGDClassifier":
		return SGDClassifier_handwritten
	elif x == "MinMaxScaler":
		return MinMaxScaler_handwritten
	elif x == "MultinomialNB":
		return MultinomialNB_handwritten
	elif x == "SimpleImputer":
		return SimpleImputer_handwritten
	elif x == "DummyClassifier":
		from lale.lib.sklearn import DummyClassifier as DummyClassifier_handwritten
		return DummyClassifier_handwritten
	elif x == "IsolationForest":
		from lale.lib.sklearn import IsolationForest as IsolationForest_handwritten
		return IsolationForest_handwritten
	elif x == "LinearSVR":
		from lale.lib.sklearn import LinearSVR as LinearSVR_handwritten
		return LinearSVR_handwritten
	elif x == "StackingClassifier":
		from lale.lib.sklearn import StackingClassifier as StackingClassifier_handwritten
		return StackingClassifier_handwritten
	elif x == "StackingRegressor":
		from lale.lib.sklearn import StackingRegressor as StackingRegressor_handwritten
		return StackingRegressor_handwritten
	elif x == "VarianceThreshold":
		from lale.lib.sklearn import VarianceThreshold as VarianceThreshold_handwritten
		return VarianceThreshold_handwritten
	elif x == "VotingRegressor":
		from lale.lib.sklearn import VotingRegressor as VotingRegressor_handwritten
		return VotingRegressor_handwritten

	return None

def get_lale_autogen(x):
	if x == "QuantileTransformer":
		return QuantileTransformer_autogen
	elif x == "QuadraticDiscriminantAnalysis":
		return QuadraticDiscriminantAnalysis_autogen
	elif x == "Normalizer":
		return Normalizer_autogen
	elif x == "MultinomialNB":
		return MultinomialNB_autogen
	elif x == "DecisionTreeRegressor":
		return DecisionTreeRegressor_autogen
	elif x == "KNeighborsRegressor":
		return KNeighborsRegressor_autogen
	elif x == "SVC":
		return SVC_autogen
	elif x == "OneHotEncoder":
		return OneHotEncoder_autogen
	elif x == "RFE":
		return None
	elif x == "FeatureAgglomeration":
		return None
	elif x == "SGDClassifier":
		return SGDClassifier_autogen
	elif x == "RandomForestClassifier":
		return RandomForestClassifier_autogen
	elif x == "FunctionTransformer":
		return FunctionTransformer_autogen
	elif x == "PolynomialFeatures":
		return PolynomialFeatures_autogen
	elif x == "SimpleImputer":
		return SimpleImputer_autogen
	elif x == "Ridge":
		return Ridge_autogen
	elif x == "StandardScaler":
		return StandardScaler_autogen
	elif x == "GradientBoostingRegressor":
		return GradientBoostingRegressor_autogen
	elif x == "RidgeClassifier":
		return RidgeClassifier_autogen
	elif x == "GradientBoostingClassifier":
		return GradientBoostingClassifier_autogen
	elif x == "LogisticRegression":
		return LogisticRegression_autogen
	elif x == "RandomForestRegressor":
		return RandomForestRegressor_autogen
	elif x == "SVR":
		return SVR_autogen
	elif x == "VotingClassifier":
		return None
	elif x == "GaussianNB":
		return GaussianNB_autogen
	elif x == "SGDRegressor":
		return SGDRegressor_autogen
	elif x == "LinearRegression":
		return LinearRegression_autogen
	elif x == "PCA":
		return PCA_autogen
	elif x == "MissingIndicator":
		return MissingIndicator_autogen
	elif x == "AdaBoostClassifier":
		return AdaBoostClassifier_autogen
	elif x == "ExtraTreesClassifier":
		return ExtraTreesClassifier_autogen
	elif x == "SelectKBest":
		return None
	elif x == "TfidfVectorizer":
		return None
	elif x == "Nystroem":
		return Nystroem_autogen
	elif x == "Pipeline":
		return None
	elif x == "ColumnTransformer":
		return None
	elif x == "RobustScaler":
		return RobustScaler_autogen
	elif x == "DecisionTreeClassifier":
		return DecisionTreeClassifier_autogen
	elif x == "NMF":
		return NMF_autogen
	elif x == "MinMaxScaler":
		return MinMaxScaler_autogen
	elif x == "AdaBoostRegressor":
		return AdaBoostRegressor_autogen
	elif x == "ExtraTreesRegressor":
		return ExtraTreesRegressor_autogen
	elif x == "BaggingClassifier":
		return None
	elif x == "LinearSVC":
		return LinearSVC_autogen
	elif x == "MLPClassifier":
		return MLPClassifier_autogen
	elif x == "OrdinalEncoder":
		return OrdinalEncoder_autogen
	elif x == "PassiveAggressiveClassifier":
		return PassiveAggressiveClassifier_autogen
	elif x == "KNeighborsClassifier":
		return KNeighborsClassifier_autogen
	elif x == "DummyClassifier":
		return None
	elif x == "IsolationForest":
		return None
	elif x == "LinearSVR":
		from lale.lib.autogen import LinearSVR as LinearSVR_autogen
		return LinearSVR_autogen
	elif x == "StackingClassifier":
		return None
	elif x == "StackingRegressor":
		return None
	elif x == "VarianceThreshold":
		return None
	elif x == "VotingRegressor":
		return None
	elif x == "AdditiveChi2Sampler":
		from lale.lib.autogen import AdditiveChi2Sampler as AdditiveChi2Sampler_autogen
		return AdditiveChi2Sampler_autogen
	elif x == "ARDRegression":
		from lale.lib.autogen import ARDRegression as ARDRegression_autogen
		return ARDRegression_autogen
	elif x == "BayesianRidge":
		from lale.lib.autogen import BayesianRidge as BayesianRidge_autogen
		return BayesianRidge_autogen
	elif x == "BernoulliNB":
		from lale.lib.autogen import BernoulliNB as BernoulliNB_autogen
		return BernoulliNB_autogen
	elif x == "BernoulliRBM":
		from lale.lib.autogen import BernoulliRBM as BernoulliRBM_autogen
		return BernoulliRBM_autogen
	elif x == "Perceptron":
		from lale.lib.autogen import Perceptron as Perceptron_autogen
		return Perceptron_autogen
	elif x == "Binarizer":
		from lale.lib.autogen import Binarizer as Binarizer_autogen
		return Binarizer_autogen
	elif x == "Birch":
		from lale.lib.autogen import Birch as Birch_autogen
		return Birch_autogen
	elif x == "CalibratedClassifierCV":
		from lale.lib.autogen import CalibratedClassifierCV as CalibratedClassifierCV_autogen
		return CalibratedClassifierCV_autogen
	elif x == "CCA":
		from lale.lib.autogen import CCA as CCA_autogen
		return CCA_autogen
	elif x == "ComplementNB":
		from lale.lib.autogen import ComplementNB as ComplementNB_autogen
		return ComplementNB_autogen
	elif x == "ElasticNet":
		from lale.lib.autogen import ElasticNet as ElasticNet_autogen
		return ElasticNet_autogen
	elif x == "ElasticNetCV":
		from lale.lib.autogen import ElasticNetCV as ElasticNetCV_autogen
		return ElasticNetCV_autogen
	elif x == "FactorAnalysis":
		from lale.lib.autogen import FactorAnalysis as FactorAnalysis_autogen
		return FactorAnalysis_autogen
	elif x == "FastICA":
		from lale.lib.autogen import FastICA as FastICA_autogen
		return FastICA_autogen
	elif x == "GaussianProcessClassifier":
		from lale.lib.autogen import GaussianProcessClassifier as GaussianProcessClassifier_autogen
		return GaussianProcessClassifier_autogen
	elif x == "GaussianProcessRegressor":
		from lale.lib.autogen import GaussianProcessRegressor as GaussianProcessRegressor_autogen
		return GaussianProcessRegressor_autogen
	elif x == "GaussianRandomProjection":
		from lale.lib.autogen import GaussianRandomProjection as GaussianRandomProjection_autogen
		return GaussianRandomProjection_autogen
	elif x == "HuberRegressor":
		from lale.lib.autogen import HuberRegressor as HuberRegressor_autogen
		return HuberRegressor_autogen
	elif x == "IncrementalPCA":
		from lale.lib.autogen import IncrementalPCA as IncrementalPCA_autogen
		return IncrementalPCA_autogen
	elif x == "KBinsDiscretizer":
		from lale.lib.autogen import KBinsDiscretizer as KBinsDiscretizer_autogen
		return KBinsDiscretizer_autogen
	elif x == "KernelPCA":
		from lale.lib.autogen import KernelPCA as KernelPCA_autogen
		return KernelPCA_autogen
	elif x == "KernelRidge":
		from lale.lib.autogen import KernelRidge as KernelRidge_autogen
		return KernelRidge_autogen
	elif x == "LabelBinarizer":
		from lale.lib.autogen import LabelBinarizer as LabelBinarizer_autogen
		return LabelBinarizer_autogen
	elif x == "LabelPropagation":
		from lale.lib.autogen import LabelPropagation as LabelPropagation_autogen
		return LabelPropagation_autogen
	elif x == "LabelSpreading":
		from lale.lib.autogen import LabelSpreading as LabelSpreading_autogen
		return LabelSpreading_autogen
	elif x == "Lars":
		from lale.lib.autogen import Lars as Lars_autogen
		return Lars_autogen
	elif x == "LarsCV":
		from lale.lib.autogen import LarsCV as LarsCV_autogen
		return LarsCV_autogen
	elif x == "Lasso":
		from lale.lib.autogen import Lasso as Lasso_autogen
		return Lasso_autogen
	elif x == "LassoCV":
		from lale.lib.autogen import LassoCV as LassoCV_autogen
		return LassoCV_autogen
	elif x == "LassoLars":
		from lale.lib.autogen import LassoLars as LassoLars_autogen
		return LassoLars_autogen
	elif x == "LassoLarsCV":
		from lale.lib.autogen import LassoLarsCV as LassoLarsCV_autogen
		return LassoLarsCV_autogen
	elif x == "LassoLarsIC":
		from lale.lib.autogen import LassoLarsIC as LassoLarsIC_autogen
		return LassoLarsIC_autogen
	elif x == "LatentDirichletAllocation":
		from lale.lib.autogen import LatentDirichletAllocation as LatentDirichletAllocation_autogen
		return LatentDirichletAllocation_autogen
	elif x == "LinearDiscriminantAnalysis":
		from lale.lib.autogen import LinearDiscriminantAnalysis as LinearDiscriminantAnalysis_autogen
		return LinearDiscriminantAnalysis_autogen
	elif x == "LocallyLinearEmbedding":
		from lale.lib.autogen import LocallyLinearEmbedding as LocallyLinearEmbedding_autogen
		return LocallyLinearEmbedding_autogen
	elif x == "MaxAbsScaler":
		from lale.lib.autogen import MaxAbsScaler as MaxAbsScaler_autogen
		return MaxAbsScaler_autogen
	elif x == "MiniBatchKMeans":
		from lale.lib.autogen import MiniBatchKMeans as MiniBatchKMeans_autogen
		return MiniBatchKMeans_autogen
	elif x == "MultiLabelBinarizer":
		from lale.lib.autogen import MultiLabelBinarizer as MultiLabelBinarizer_autogen
		return MultiLabelBinarizer_autogen
	elif x == "MultiTaskElasticNet":
		from lale.lib.autogen import MultiTaskElasticNet as MultiTaskElasticNet_autogen
		return MultiTaskElasticNet_autogen
	elif x == "NearestCentroid":
		from lale.lib.autogen import NearestCentroid as NearestCentroid_autogen
		return NearestCentroid_autogen
	elif x == "NuSVC":
		from lale.lib.autogen import NuSVC as NuSVC_autogen
		return NuSVC_autogen
	elif x == "OrthogonalMatchingPursuit":
		from lale.lib.autogen import OrthogonalMatchingPursuit as OrthogonalMatchingPursuit_autogen
		return OrthogonalMatchingPursuit_autogen
	elif x == "OrthogonalMatchingPursuitCV":
		from lale.lib.autogen import OrthogonalMatchingPursuitCV as OrthogonalMatchingPursuitCV_autogen
		return OrthogonalMatchingPursuitCV_autogen
	elif x == "PassiveAggressiveRegressor":
		from lale.lib.autogen import PassiveAggressiveRegressor as PassiveAggressiveRegressor_autogen
		return PassiveAggressiveRegressor_autogen
	elif x == "PLSCanonical":
		from lale.lib.autogen import PLSCanonical as PLSCanonical_autogen
		return PLSCanonical_autogen
	elif x == "PowerTransformer":
		from lale.lib.autogen import PowerTransformer as PowerTransformer_autogen
		return PowerTransformer_autogen
	elif x == "RadiusNeighborsClassifier":
		from lale.lib.autogen import RadiusNeighborsClassifier as RadiusNeighborsClassifier_autogen
		return RadiusNeighborsClassifier_autogen
	elif x == "RANSACRegressor":
		from lale.lib.autogen import RANSACRegressor as RANSACRegressor_autogen
		return RANSACRegressor_autogen
	elif x == "RBFSampler":
		from lale.lib.autogen import RBFSampler as RBFSampler_autogen
		return RBFSampler_autogen
	elif x == "RidgeClassifierCV":
		from lale.lib.autogen import RidgeClassifierCV as RidgeClassifierCV_autogen
		return RidgeClassifierCV_autogen
	elif x == "SkewedChi2Sampler":
		from lale.lib.autogen import SkewedChi2Sampler as SkewedChi2Sampler_autogen
		return SkewedChi2Sampler_autogen
	elif x == "SparseRandomProjection":
		from lale.lib.autogen import SparseRandomProjection as SparseRandomProjection_autogen
		return SparseRandomProjection_autogen
	elif x == "TransformedTargetRegressor":
		from lale.lib.autogen import TransformedTargetRegressor as TransformedTargetRegressor_autogen
		return TransformedTargetRegressor_autogen
	elif x == "TruncatedSVD":
		from lale.lib.autogen import TruncatedSVD as TruncatedSVD_autogen
		return TruncatedSVD_autogen
	elif x == "KMeans":
		from lale.lib.autogen import KMeans as KMeans_autogen
		return KMeans_autogen
	elif x == "MiniBatchDictionaryLearning":
		from lale.lib.autogen import MiniBatchDictionaryL
	elif x == "MiniBatchSparsePCA":
		from lale.lib.autogen import MiniBatchSparsePCA as MiniBatchSparsePCA_autogen
		return MiniBatchSparsePCA_autogen
	elif x == "NuSVR":
		from lale.lib.autogen import NuSVR as NuSVR_autogen
		return NuSVR_autogen
	elif x == "RadiusNeighborsRegressor":
		from lale.lib.autogen import RadiusNeighborsRegressor as RadiusNeighborsRegressor_autogen
		return RadiusNeighborsRegressor_autogen
	elif x == "RidgeCV":
		from lale.lib.autogen import RidgeCV as RidgeCV_autogen
		return RidgeCV_autogen
	elif x == "SparsePCA":
		from lale.lib.autogen import SparsePCA as SparsePCA_autogen
		return SparsePCA_autogen
	elif x == "TheilSenRegressor":
		from lale.lib.autogen import TheilSenRegressor as TheilSenRegressor_autogen
		return TheilSenRegressor_autogen


# UPPPPP
	return None


def getRelevantToOptimizer(x):
	if x == "AdaBoostClassifier":
		return ['algorithm', 'learning_rate', 'n_estimators']
	elif x == "AdaBoostRegressor":
		return ['learning_rate', 'loss', 'n_estimators']
	elif x == "BaggingClassifier":
		return ['bootstrap', 'bootstrap_features', 'max_features', 'max_samples', 'n_estimators', 'oob_score', 'warm_start']
	elif x == "ColumnTransformer":
		return ['sparse_threshold']
	elif x == "DecisionTreeClassifier":
		return ['criterion', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'splitter']
	elif x == "DecisionTreeRegressor":
		return ['criterion', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'splitter']
	elif x == "ExtraTreesClassifier":
		return ['bootstrap', 'criterion', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'n_estimators', 'oob_score', 'warm_start']
	elif x == "ExtraTreesRegressor":
		return ['bootstrap', 'criterion', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'n_estimators', 'oob_score', 'warm_start']
	elif x == "FeatureAgglomeration":
		return ['affinity', 'compute_full_tree', 'linkage', 'n_clusters']
	elif x == "FunctionTransformer":
		return ['accept_sparse', 'check_inverse', 'pass_y', 'validate']
	elif x == "GaussianNB":
		return ['var_smoothing']
	elif x == "GradientBoostingClassifier":
		return ['criterion', 'learning_rate', 'loss', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'n_estimators', 'n_iter_no_change', 'subsample', 'tol', 'validation_fraction', 'warm_start']
	elif x == "GradientBoostingRegressor":
		return ['alpha', 'criterion', 'learning_rate', 'loss', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'n_estimators', 'n_iter_no_change', 'subsample', 'tol', 'validation_fraction', 'warm_start']
	elif x == "KNeighborsClassifier":
		return ['algorithm', 'leaf_size', 'metric', 'n_neighbors', 'p']
	elif x == "KNeighborsRegressor":
		return ['algorithm', 'leaf_size', 'metric', 'n_neighbors', 'p']
	elif x == "LinearRegression":
		return ['copy_X', 'fit_intercept', 'normalize']
	elif x == "LinearSVC":
		return ['C', 'dual', 'fit_intercept', 'intercept_scaling', 'loss', 'max_iter', 'multi_class', 'penalty', 'tol']
	elif x == "LogisticRegression":
		return ['C', 'dual', 'fit_intercept', 'intercept_scaling', 'max_iter', 'multi_class', 'penalty', 'solver', 'tol', 'warm_start', 'l1_ratio']
	elif x == "MLPClassifier":
		return ['activation', 'alpha', 'batch_size', 'beta_1', 'beta_2', 'early_stopping', 'epsilon', 'hidden_layer_sizes', 'learning_rate', 'learning_rate_init', 'max_iter', 'momentum', 'n_iter_no_change', 'nesterovs_momentum', 'power_t', 'shuffle', 'solver', 'tol', 'validation_fraction', 'warm_start']
	elif x == "MinMaxScaler":
		return ['copy', 'feature_range']
	elif x == "MissingIndicator":
		return ['error_on_new', 'features', 'sparse']
	elif x == "MultinomialNB":
		return ['alpha', 'fit_prior']
	elif x == "NMF":
		return ['alpha', 'beta_loss', 'l1_ratio', 'max_iter', 'n_components', 'shuffle', 'solver', 'tol']
	elif x == "Normalizer":
		return ['copy', 'norm']
	elif x == "Nystroem":
		return ['coef0', 'degree', 'gamma', 'kernel', 'n_components']
	elif x == "OneHotEncoder":
		return ['handle_unknown', 'sparse']
	elif x == "OrdinalEncoder":
		return ['handle_unknown']
	elif x == "PCA":
		return ['copy', 'iterated_power', 'n_components', 'svd_solver', 'tol', 'whiten']
	elif x == "PassiveAggressiveClassifier":
		return ['C', 'average', 'early_stopping', 'fit_intercept', 'loss', 'max_iter', 'n_iter', 'n_iter_no_change', 'shuffle', 'tol', 'validation_fraction', 'warm_start']
	elif x == "Pipeline":
		return []
	elif x == "PolynomialFeatures":
		return ['degree', 'include_bias', 'interaction_only']
	elif x == "QuadraticDiscriminantAnalysis":
		return ['reg_param', 'store_covariance', 'tol']
	elif x == "QuantileTransformer":
		return ['copy', 'ignore_implicit_zeros', 'n_quantiles', 'output_distribution', 'subsample']
	elif x == "RFE":
		return ['n_features_to_select', 'step']
	elif x == "RandomForestClassifier":
		return ['bootstrap', 'criterion', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'n_estimators', 'oob_score', 'warm_start']
	elif x == "RandomForestRegressor":
		return ['bootstrap', 'criterion', 'max_depth', 'max_features', 'max_leaf_nodes', 'min_impurity_decrease', 'min_samples_leaf', 'min_samples_split', 'min_weight_fraction_leaf', 'n_estimators', 'oob_score', 'warm_start']
	elif x == "Ridge":
		return ['alpha', 'copy_X', 'fit_intercept', 'max_iter', 'normalize', 'solver', 'tol']
	elif x == "RidgeClassifier":
		return ['alpha', 'copy_X', 'fit_intercept', 'max_iter', 'normalize', 'solver', 'tol']
	elif x == "RobustScaler":
		return ['copy', 'quantile_range', 'with_centering', 'with_scaling']
	elif x == "SGDClassifier":
		return ['alpha', 'average', 'early_stopping', 'epsilon', 'eta0', 'fit_intercept', 'l1_ratio', 'learning_rate', 'loss', 'max_iter', 'n_iter_no_change', 'penalty', 'power_t', 'shuffle', 'tol', 'validation_fraction', 'warm_start']
	elif x == "SGDRegressor":
		return ['alpha', 'average', 'early_stopping', 'epsilon', 'eta0', 'fit_intercept', 'l1_ratio', 'learning_rate', 'loss', 'max_iter', 'n_iter_no_change', 'penalty', 'power_t', 'shuffle', 'tol', 'validation_fraction', 'warm_start']
	elif x == "SVC":
		return ['C', 'cache_size', 'coef0', 'decision_function_shape', 'degree', 'gamma', 'kernel', 'max_iter', 'probability', 'shrinking', 'tol']
	elif x == "SVR":
		return ['C', 'cache_size', 'coef0', 'degree', 'epsilon', 'gamma', 'kernel', 'max_iter', 'shrinking', 'tol']
	elif x == "SelectKBest":
		return ['k']
	elif x == "SimpleImputer":
		return ['copy', 'strategy']
	elif x == "StandardScaler":
		return ['copy', 'with_mean', 'with_std']
	elif x == "TfidfVectorizer":
		#return ['analyzer', 'binary', 'decode_error', 'input', 'lowercase', 'max_df', 'max_features', 'min_df', 'ngram_range', 'norm', 'preprocessor', 'smooth_idf', 'strip_accents', 'sublinear_tf', 'tokenizer', 'use_idf']
		return ["analyzer", "ngram_range", "max_df", "min_df", "binary", "norm", "use_idf", "smooth_idf", "sublinear_tf"]
	elif x == "VotingClassifier":
		return ['flatten_transform', 'voting']
	elif x == "DummyClassifier":
		return ["strategy"]
	elif x == "IsolationForest": # Same as Lale's
		return ["n_estimators", "max_samples", "max_features", "bootstrap"]
	elif x == "LinearSVR": # Same as Lale's
		return ["epsilon", "tol", "loss", "fit_intercept", "dual", "max_iter"]
	elif x == "StackingClassifier":
		return ["final_estimator", "cv", "passthrough"]
	elif x == "StackingRegressor":
		return ["final_estimator", "cv", "passthrough"]
	elif x == "VarianceThreshold":
		return ["threshold"]
	elif x == "VotingRegressor":
		return []
	elif x == "AdditiveChi2Sampler":
		return ["sample_steps","sample_interval"]
	elif x == "ARDRegression": # Same as Lale's autogen
		return ["n_iter", "tol", "compute_score", "fit_intercept", "normalize", "copy_X"]
	elif x == "BayesianRidge": # Same as Lale's autogen
		return ["n_iter", "tol", "compute_score", "fit_intercept", "normalize", "copy_X"]
	elif x == "BernoulliNB": # Same as Lale's autogen
		return ["alpha", "fit_prior", "binarize"]
	elif x == "BernoulliRBM": # Same as Lale's autogen
		return ["n_components", "batch_size", "n_iter"]
	elif x == "Perceptron": # Same as Lale's autogen
		return ["alpha", "fit_intercept", "max_iter", "tol", "shuffle", "eta0"]
	elif x == "Binarizer": # Same as Lale's autogen
		return ["copy"]
	elif x == "Birch": # Same as Lale's autogen
		return ["branching_factor", "n_clusters", "compute_labels", "copy"]
	elif x == "CalibratedClassifierCV":
		return ["method", "cv", "ensemble"]
	elif x == "CCA": # Same as Lale's autogen
		return ["n_components", "scale", "max_iter", "tol", "copy"]
	elif x == "ComplementNB": 
		return ["alpha", "fit_prior", "norm"]
	elif x == "ElasticNet": # remove precompute
		return ["alpha", "fit_intercept", "max_iter", "copy_X", "tol", "positive", "selection"]
	elif x == "ElasticNetCV":
		return ["l1_ratio", "eps", "n_alphas", "alpha", "fit_intercept", "normalize", "precompute", "max_iter", "tol", "cv", "copy_X", "positive", "selection"]
	elif x == "FactorAnalysis":
		return ["tol", "copy", "svd_method", "iterated_power", "rotation"]
	elif x == "FastICA":
		return ["algorithm", "whiten", "fun", "tol"]
	elif x == "GaussianProcessClassifier": # Same as Lale's autogen
		return ["optimizer", "n_restarts_optimizer", "max_iter_predict", "multi_class"]
	elif x == "GaussianProcessRegressor":
		return ["alpha", "optimizer", "n_restarts_optimizer", "normalize_y"]
	elif x == "GaussianRandomProjection":
		return ["n_components", "eps"]
	elif x == "HuberRegressor":
		return ["epsilon", "alpha", "fit_intercept", "tol"]
	elif x == "IncrementalPCA":
		return ["whiten", "copy", "batch_size"]
	elif x == "KBinsDiscretizer":
		return ["encode", "strategy"]
	elif x == "KernelPCA":
		return ["kernel", "degree", "coef0", "alpha", "eigen_solver", "tol", "remove_zero_eig", "copy_X", "fit_inverse_transform"]
	elif x == "KernelRidge": # Same as Lale's autogen
		return ["alpha", "kernel", "degree", "coef0"]
	elif x == "LabelBinarizer": # Same as Lale's autogen
		return ["neg_label", "pos_label", "sparse_output"]
	elif x == "LabelPropagation":
		return ["kernel", "gamma", "n_neighbors", "tol"]
	elif x == "LabelSpreading":
		return ["kernel", "gamma", "n_neighbors", "alpha", "tol"]
	elif x == "Lars":
		return ["fit_intercept", "normalize", "precompute", "n_nonzero_coefs", "eps", "copy_X", "fit_path"]
	elif x == "LarsCV":# Same as Lale's autogen
		return ["fit_intercept","max_iter","normalize","precompute","cv","max_n_alphas","eps","copy_X"]
	elif x == "Lasso":# Same as Lale's autogen
		return ["alpha","fit_intercept","normalize","copy_X","max_iter","tol","positive","selection"]
	elif x == "LassoCV":# Same as Lale's autogen
		return ["eps","n_alphas","fit_intercept","normalize","precompute","max_iter","tol","copy_X","cv","positive","selection",]
	elif x == "LassoLars":# Same as Lale's autogen
		return ["alpha","fit_intercept","normalize","precompute","max_iter","eps","copy_X","positive",]
	elif x == "LassoLarsCV":# Same as Lale's autogen
		return ["fit_intercept","max_iter","normalize","precompute","cv","max_n_alphas","eps","copy_X","positive",]
	elif x == "LassoLarsIC":# Same as Lale's autogen
		return ["criterion","fit_intercept","normalize","precompute","max_iter","eps","copy_X","positive",]
	elif x == "LatentDirichletAllocation":
		return ["n_components","max_iter","batch_size","evaluate_every","total_samples","max_doc_update_iter","learning_method"]
	elif x == "LinearDiscriminantAnalysis":
		return ["solver", "n_components", "tol", "shrinkage"]
	elif x == "LocallyLinearEmbedding":
		return ["n_neighbors","eigen_solver","tol","max_iter","method","neighbors_algorithm",]
	elif x == "MaxAbsScaler":
		return ["copy"]
	elif x == "MiniBatchKMeans":# Same as Lale's autogen
		return ["n_clusters","init","max_iter","batch_size","compute_labels","tol","max_no_improvement","n_init",]
	elif x == "MultiLabelBinarizer":# Same as Lale's autogen
		return ["sparse_output"]
	elif x == "MultiTaskElasticNet":
		return ["alpha","fit_intercept","normalize","copy_X","max_iter","tol","selection"]
	elif x == "NearestCentroid":
		return ["metric", "shrink_threshold"]
	elif x == "NuSVC":
		return ["kernel","degree","gamma","shrinking","probability","tol","cache_size","max_iter","decision_function_shape","break_ties"]
	elif x == "OrthogonalMatchingPursuit":
		return ["tol","fit_intercept","normalize","precompute",]
	elif x == "OrthogonalMatchingPursuitCV":
		return ["copy","fit_intercept","normalize","max_iter","cv",]
	elif x == "PassiveAggressiveRegressor":
		return ["fit_intercept","max_iter","tol","shuffle","loss",]
	elif x == "PLSCanonical":
		return ["n_components","scale","algorithm","max_iter","tol","copy",]
	elif x == "PowerTransformer":
		return ["method", "standardize"]
	elif x == "RadiusNeighborsClassifier":
		return ["weights", "algorithm", "leaf_size", "p", "metric", "outlier_label"]
	elif x == "RadiusNeighborsRegressor":
		return ["weights", "algorithm", "leaf_size", "p", "metric"]
	elif x == "RANSACRegressor":# Same as Lale's autogen
		return ["min_samples","max_trials","max_skips","stop_n_inliers","loss",]
	elif x == "RBFSampler":# Same as Lale's autogen
		return ["n_components"]
	elif x== "RidgeClassifierCV":
		return ["fit_intercept", "normalize", "cv", "class_weight", "store_cv_values"]
	elif x == "SkewedChi2Sampler":# Same as Lale's autogen
		return ["n_components"]
	elif x == "SparseRandomProjection":
		return ["n_components", "density", "eps", "dense_output"]
	elif x == "TransformedTargetRegressor":
		return []
	elif x == "TruncatedSVD":
		return ["algorithm", "n_iter", "tol"]


